Click on the link below for the answers

http://bit.ly/2xrESxf

If you don't click on that url, because you're a caveman (or
cavewoman), you can also copy and paste everything below
into https://play.kotlinlang.org.

fun main() {
    val full = false

    if (!full) {

        //Part 1: Burger AND Fries
        //Burger Empire always like to start with your burger
        //and fries. Calculate the price of John's current burger
        //and fries order.
        val priceOfBurgerAndFries = calculateBurgerAndFriesPrice(listOf("BURGER", "FRIES", "KETCHUP", "RACCOON"))

        //Part 2: Mango OR Strawberry?
        //Burger Empire is having a hard time getting its customers to buy
        //shakes. As an incentive to buy the more expensive mango or strawberry
        //shake flavors, Burger Empire offers it's customers a free chocolate
        //chip cookie.
        val priceOfShakes = calculateShakePrice(listOf("MANGO", "", "PEANUT BUTTER", "JELLY"))

        //Part 3: NOT Full
        //John, our most loyal customers, has an addiction to Burger Empire and he
        //wants to start being more responsible with his food choices. You, as the
        //programmer, should prevent John from making any purchases if he is already full
        //but how do you do this? Well, welcome to the world of programming, where
        //there is typically more than one way to do the exact same thing.

        //BONUS: Add up how much John's order cost and print it to the screen!
        println(priceOfBurgerAndFries + priceOfShakes.first)
    } else {
        println("You've had enough, go home!")
    }
}


/* If a customer orders a burger AND fries,
* charge them 3.50. Otherwise, the Burger
* is 3.00 and the fries are 2.00
* return the total value of this part of the order
* as a Double. Assume that you CANNOT buy more than
* one burger and one fry.
**/
fun calculateBurgerAndFriesPrice(orderItems: List<String>): Double {
    var orderTotal = 0.0

    if (orderItems.contains("BURGER") && orderItems.contains("FRIES")) {
        orderTotal = orderTotal + 3.50
    } else if (orderItems.contains("BURGER")) {
        orderTotal = orderTotal + 3.0
    } else if (orderItems.contains("FRIES")) {
        orderTotal = orderTotal + 2.0
    } else {
        orderTotal = 0.0
    }
    return orderTotal
}

/* Mango or strawberry shakes cost 3.25 a piece.
* If they order one, they get a cookie! In
* this case you want to return true for the
* second value of the pair. If they
* order a chocolate or vanilla shake, that costs
* 3.00 but they don't get a cookie. In this case
* return false as the second value of the pair.
* The result of calling this function should be
* something like Pair(3.25, true) if they get a cookie
* or Pair(3.00, false) if they didn't. Assume that
* you CAN buy multiple shakes, but you can only
* get one cookie. Even if you buy multiple strawberry
* or mango shakes. JUST ONE COOKIE PER CUSTOMER!
**/
fun calculateShakePrice(orderItems: List<String>): Pair<Double, Boolean> {
    var getsACookie = false

    val total = orderItems.map { it ->
        if (it == "STRAWBERRY" || it == "MANGO") {
            getsACookie = true
            3.25
        } else if (it == "CHOCOLATE") {
            3.0
        } else if (it == "VANILLA") {
            3.0
        } else {
            0.0
        }
    }

    return Pair(total.sum(), getsACookie)
}